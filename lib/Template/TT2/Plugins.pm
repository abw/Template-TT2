package Template::TT2::Plugins;
    
use Template::TT2::Class
    version   => 0.01,
    debug     => 0,
    base      => 'Template::TT2::Base',
    constants => 'HASH CODE TT2_PLUGIN',
    accessors => 'hub',
    utils     => 'is_object',
    throws    => 'plugin',
    vars      => {
        LOAD_PERL => 0,
    },
    config    => [
        'plugins|PLUGINS',
        'plugin_path|PLUGIN_PATH|PLUGIN_BASE',
        'load_perl|LOAD_PERL|class:LOAD_PERL',
    ];

use Badger::Factory::Class
    item      => 'plugin',
    path      => 'Template::TT2::Plugin Template::Plugin',
    plugins   => { 
        cgi   => 'Template::TT2::Plugin::CGI',
        url   => 'Template::TT2::Plugin::URL',
        html  => 'Template::TT2::Plugin::HTML',
    },
    messages  => {
        not_found  => "<2>: plugin not found",
        bad_plugin => "Invalid plugin definition for '%s' (%s)",
    };

# this next line isn't required with Badger 0.04_01+
our $PLUGIN_PATH;

# alias old skool PLUGIN_BASE to PLUGIN_PATH generated by factory class
*PLUGIN_BASE = \$PLUGIN_PATH;


sub find {
    my ($self, $type, $args) = @_;
    my $class = $self->SUPER::find($type, $args) || return;
# TODO: tmp hack
#    $self->{ $self->{ items } }->{ $type } = $class;
    $self->debug("loaded $type => $class - adding to $self->{ items }") if DEBUG;
    my $r = $class->load($args->[0]);
#    $self->debug("load() returned $r");
    return $r;
}

sub init {
    my ($self, $config) = @_;
    # have the configure() method update $config instead of $self
    $self->configure($config => $config);
    $self->{ load_perl } = $config->{ load_perl };
    return $self->init_factory($config);
}

sub not_found {
    my ($self, $name, $args) = @_;

    $self->debug("not found: $name");
    if ($self->{ load_perl }) {
            # this is a regular Perl module so the new() constructor
            # isn't expecting a $context reference as the first argument;
            # so we construct a closure which removes it before calling
            # $module->new(@_);
#            $factory = sub {
#                shift;
#                $module->new(@_);
#            };
#            $error   = '';
#        }
    }
    $self->error_msg( not_found => $self->{ item }, $name );
}

    
1;

__END__

sub _load {
    my ($self, $name, $context) = @_;
    my ($factory, $module, $base, $pkg, $file, $ok, $error);

    if ($module = $self->{ PLUGINS }->{ $name } || $self->{ PLUGINS }->{ lc $name }) {
        # plugin module name is explicitly stated in PLUGIN_NAME
        $pkg = $module;
        ($file = $module) =~ s|::|/|g;
        $file =~ s|::|/|g;
        $self->debug("loading $module.pm (PLUGIN_NAME)")
            if $self->{ DEBUG };
        $ok = eval { require "$file.pm" };
        $error = $@;
    }
    else {
        # try each of the PLUGIN_BASE values to build module name
        ($module = $name) =~ s/\./::/g;
        
        foreach $base (@{ $self->{ PLUGIN_BASE } }) {
            $pkg = $base . '::' . $module;
            ($file = $pkg) =~ s|::|/|g;
            
            $self->debug("loading $file.pm (PLUGIN_BASE)")
                if $self->{ DEBUG };
            
            $ok = eval { require "$file.pm" };
            last unless $@;
            
            $error .= "$@\n" 
                unless ($@ =~ /^Can\'t locate $file\.pm/);
        }
    }
    
    if ($ok) {
        $self->debug("calling $pkg->load()") if $self->{ DEBUG };

        $factory = eval { $pkg->load($context) };
        $error   = '';
        if ($@ || ! $factory) {
            $error = $@ || 'load() returned a false value';
        }
    }
    elsif ($self->{ LOAD_PERL }) {
        # fallback - is it a regular Perl module?
        ($file = $module) =~ s|::|/|g;
        eval { require "$file.pm" };
        if ($@) {
            $error = $@;
        }
        else {
            # this is a regular Perl module so the new() constructor
            # isn't expecting a $context reference as the first argument;
            # so we construct a closure which removes it before calling
            # $module->new(@_);
            $factory = sub {
                shift;
                $module->new(@_);
            };
            $error   = '';
        }
    }
    
    if ($factory) {
        $self->debug("$name => $factory") if $self->{ DEBUG };
        return $factory;
    }
    elsif ($error) {
        return $self->{ TOLERANT } 
            ? (undef,  Template::Constants::STATUS_DECLINED) 
            : ($error, Template::Constants::STATUS_ERROR);
    }
    else {
        return (undef, Template::Constants::STATUS_DECLINED);
    }
}

