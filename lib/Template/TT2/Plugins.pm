package Template::TT2::Plugins;
    
use Template::TT2::Class
    version   => 0.01,
    debug     => 0,
    base      => 'Template::TT2::Base',
    constants => 'HASH CODE TT2_PLUGIN',
    accessors => 'hub',
#    import    => 'class',
    utils     => 'is_object',
    throws    => 'plugin',
    vars      => {
        LOAD_PERL => 0,
    },
    config    => [
        'plugins|PLUGINS',
        'plugin_path|PLUGIN_PATH|PLUGIN_BASE',
        'load_perl|LOAD_PERL|class:LOAD_PERL',
    ];

use Badger::Factory::Class
    item      => 'plugin',
    path      => 'Template::TT2::Plugin Template::Plugin',
    plugins   => { 
        cgi   => 'Template::TT2::Plugin::CGI',
        url   => 'Template::TT2::Plugin::URL',
        html  => 'Template::TT2::Plugin::HTML',
    },
    messages  => {
        not_found  => "<2>: plugin not found",
        bad_plugin => "Invalid plugin definition for '%s' (%s)",
    };

# alias old skool PLUGIN_BASE to PLUGIN_PATH generated by factory class
*PLUGIN_BASE = \$PLUGIN_PATH;


sub init {
    my ($self, $config) = @_;
    # have the configure() method update $config instead of $self
    $self->configure($config => $config);
    $self->{ load_perl } = $config->{ load_perl };
    return $self->init_factory($config);
}


sub load_class {
    my ($self, $module, $class, $args) = @_;
    my $load_class;
    
    if ($load_class = $self->{ load_class }->{ $module }) {
        $self->debug("$module is already loaded, class is $load_class") if DEBUG;
    }
    else {
        $self->debug("loading: $module") if DEBUG;
        $self->load($module);
        $class ||= $module;
        $load_class = $self->{ load_class }->{ $module } = $class->load($args->[0]);
        $self->debug("load() returned class: $class") if DEBUG;
    }
    return $load_class;
}


sub found_module {
    my ($self, $type, $module, $args) = @_;
    my $class = $self->load_class($module, $module, $args);
    return $self->construct($type, $class, $args);
}


sub found_array {
    my ($self, $type, $list, $args) = @_;
    my ($module, $class) = @$list;
    $class = $self->load_class($module, $class, $args);
    return $self->construct($type, $class, $args);
}


sub found_code {
    my ($self, $name, $code, $args) = @_;
    # if we've got a code ref in the plugins table (possibly a closure
    # generated by not_found() below) then we call it
    return $code->(@$args);
}


sub not_found {
    my ($self, $name, $args) = @_;

    $self->debug("not found: $name") if DEBUG;
    
    if ($self->{ load_perl }) {
        $self->debug("Attempting to LOAD_PERL for $name\n") if DEBUG;

        if (my $module = $self->load( $self->module_names($name) )) {
            $self->debug("Loaded $module") if DEBUG;

            # Construct a closure which removes the $context reference from 
            # the argument list before calling the new() method.  We can use 
            # it now and cache it in $self->{ plugins } for next time.
            my $factory = $self->{ $self->{ items } }->{ $name } = sub {
                shift;  # ignore $context
                $module->new(@_);
            };
    
            return $factory->(@$args);
        }
    }
    $self->error_msg( not_found => $self->{ item }, $name );
}

    
1;

__END__

sub _load {
    my ($self, $name, $context) = @_;
    my ($factory, $module, $base, $pkg, $file, $ok, $error);

    if ($module = $self->{ PLUGINS }->{ $name } || $self->{ PLUGINS }->{ lc $name }) {
        # plugin module name is explicitly stated in PLUGIN_NAME
        $pkg = $module;
        ($file = $module) =~ s|::|/|g;
        $file =~ s|::|/|g;
        $self->debug("loading $module.pm (PLUGIN_NAME)")
            if $self->{ DEBUG };
        $ok = eval { require "$file.pm" };
        $error = $@;
    }
    else {
        # try each of the PLUGIN_BASE values to build module name
        ($module = $name) =~ s/\./::/g;
        
        foreach $base (@{ $self->{ PLUGIN_BASE } }) {
            $pkg = $base . '::' . $module;
            ($file = $pkg) =~ s|::|/|g;
            
            $self->debug("loading $file.pm (PLUGIN_BASE)")
                if $self->{ DEBUG };
            
            $ok = eval { require "$file.pm" };
            last unless $@;
            
            $error .= "$@\n" 
                unless ($@ =~ /^Can\'t locate $file\.pm/);
        }
    }
    
    if ($ok) {
        $self->debug("calling $pkg->load()") if $self->{ DEBUG };

        $factory = eval { $pkg->load($context) };
        $error   = '';
        if ($@ || ! $factory) {
            $error = $@ || 'load() returned a false value';
        }
    }
    elsif ($self->{ LOAD_PERL }) {
        # fallback - is it a regular Perl module?
        ($file = $module) =~ s|::|/|g;
        eval { require "$file.pm" };
        if ($@) {
            $error = $@;
        }
        else {
            # this is a regular Perl module so the new() constructor
            # isn't expecting a $context reference as the first argument;
            # so we construct a closure which removes it before calling
            # $module->new(@_);
            $factory = sub {
                shift;
                $module->new(@_);
            };
            $error   = '';
        }
    }
    
    if ($factory) {
        $self->debug("$name => $factory") if $self->{ DEBUG };
        return $factory;
    }
    elsif ($error) {
        return $self->{ TOLERANT } 
            ? (undef,  Template::Constants::STATUS_DECLINED) 
            : ($error, Template::Constants::STATUS_ERROR);
    }
    else {
        return (undef, Template::Constants::STATUS_DECLINED);
    }
}

